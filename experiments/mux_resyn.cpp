#include "experiments.hpp"

#include <mockturtle/networks/muxig.hpp>
#include <mockturtle/algorithms/resyn_engines/mux_resyn.hpp>
#include <mockturtle/utils/stopwatch.hpp>

#include <kitty/kitty.hpp>
#include <fmt/format.h>

int main()
{
  using namespace mockturtle;
  using namespace experiments;

  using truth_table_type = kitty::dynamic_truth_table;
  
  std::vector<truth_table_type> divisor_functions;
  std::vector<uint32_t> divisors;
  truth_table_type x( 4 ), target( 4 ), care( 4 );
  care = ~care;
  for ( uint32_t i = 0; i < 4; ++i )
  {
    kitty::create_nth_var( x, i );
    divisor_functions.emplace_back( x );
    divisors.emplace_back( i );
  }

  using resyn_engine_t = mux_resyn<truth_table_type>;
  typename resyn_engine_t::stats st;
  resyn_engine_t engine( st );

  const std::vector<uint16_t> classes{ { 0x0000, 0x0001, 0x0003, 0x0006, 0x0007, 0x000f, 0x0016, 0x0017, 0x0018, 0x0019, 0x001b, 0x001e, 0x001f, 0x003c, 0x003d, 0x003f, 0x0069, 0x006b, 0x006f, 0x007e, 0x007f, 0x00ff, 0x0116, 0x0117, 0x0118, 0x0119, 0x011a, 0x011b, 0x011e, 0x011f, 0x012c, 0x012d, 0x012f, 0x013c, 0x013d, 0x013e, 0x013f, 0x0168, 0x0169, 0x016a, 0x016b, 0x016e, 0x016f, 0x017e, 0x017f, 0x0180, 0x0181, 0x0182, 0x0183, 0x0186, 0x0187, 0x0189, 0x018b, 0x018f, 0x0196, 0x0197, 0x0198, 0x0199, 0x019a, 0x019b, 0x019e, 0x019f, 0x01a8, 0x01a9, 0x01aa, 0x01ab, 0x01ac, 0x01ad, 0x01ae, 0x01af, 0x01bc, 0x01bd, 0x01be, 0x01bf, 0x01e8, 0x01e9, 0x01ea, 0x01eb, 0x01ee, 0x01ef, 0x01fe, 0x033c, 0x033d, 0x033f, 0x0356, 0x0357, 0x0358, 0x0359, 0x035a, 0x035b, 0x035e, 0x035f, 0x0368, 0x0369, 0x036a, 0x036b, 0x036c, 0x036d, 0x036e, 0x036f, 0x037c, 0x037d, 0x037e, 0x03c0, 0x03c1, 0x03c3, 0x03c5, 0x03c6, 0x03c7, 0x03cf, 0x03d4, 0x03d5, 0x03d6, 0x03d7, 0x03d8, 0x03d9, 0x03db, 0x03dc, 0x03dd, 0x03de, 0x03fc, 0x0660, 0x0661, 0x0662, 0x0663, 0x0666, 0x0667, 0x0669, 0x066b, 0x066f, 0x0672, 0x0673, 0x0676, 0x0678, 0x0679, 0x067a, 0x067b, 0x067e, 0x0690, 0x0691, 0x0693, 0x0696, 0x0697, 0x069f, 0x06b0, 0x06b1, 0x06b2, 0x06b3, 0x06b4, 0x06b5, 0x06b6, 0x06b7, 0x06b9, 0x06bd, 0x06f0, 0x06f1, 0x06f2, 0x06f6, 0x06f9, 0x0776, 0x0778, 0x0779, 0x077a, 0x077e, 0x07b0, 0x07b1, 0x07b4, 0x07b5, 0x07b6, 0x07bc, 0x07e0, 0x07e1, 0x07e2, 0x07e3, 0x07e6, 0x07e9, 0x07f0, 0x07f1, 0x07f2, 0x07f8, 0x0ff0, 0x1668, 0x1669, 0x166a, 0x166b, 0x166e, 0x167e, 0x1681, 0x1683, 0x1686, 0x1687, 0x1689, 0x168b, 0x168e, 0x1696, 0x1697, 0x1698, 0x1699, 0x169a, 0x169b, 0x169e, 0x16a9, 0x16ac, 0x16ad, 0x16bc, 0x16e9, 0x177e, 0x178e, 0x1796, 0x1798, 0x179a, 0x17ac, 0x17e8, 0x18e7, 0x19e1, 0x19e3, 0x19e6, 0x1bd8, 0x1be4, 0x1ee1, 0x3cc3, 0x6996 } };
  const std::vector<uint32_t> opt_sizes{ { 0, 3, 2, 3, 3, 1, 4, 3, 4, 3, 2, 3, 3, 2, 3, 2, 3, 4, 3, 4, 3, 0, 5, 4, 4, 4, 4, 3, 4, 3, 4, 3, 2, 4, 3, 4, 3, 5, 4, 4, 4, 4, 3, 4, 3, 3, 3, 4, 3, 4, 4, 3, 3, 3, 5, 4, 4, 3, 4, 3, 4, 4, 4, 3, 3, 2, 3, 3, 3, 3, 4, 3, 4, 3, 4, 4, 4, 3, 3, 2, 3, 3, 4, 2, 3, 3, 3, 3, 3, 3, 3, 2, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 3, 3, 2, 3, 3, 3, 1, 4, 3, 4, 3, 3, 3, 3, 3, 2, 3, 2, 3, 5, 4, 4, 3, 4, 4, 5, 3, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 2, 4, 4, 4, 3, 4, 3, 4, 3, 4, 4, 3, 4, 3, 2, 3, 4, 4, 4, 3, 4, 4, 4, 3, 3, 4, 3, 4, 4, 4, 3, 3, 4, 3, 3, 2, 3, 1, 5, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 3, 3, 4, 3, 3, 3, 4, 4, 4, 3, 3, 2, 3, 2, 3 } };


  experiment<std::string, uint32_t, uint32_t, float> exp( "muxig_resyn", "class", "opt", "resyn", "time" );
  uint32_t num_success{0}, total_size{0}, total_overhead{0};

  for ( auto i = 0u; i < classes.size(); ++i )
  {
    target._bits[0] = classes[i];
    stopwatch<>::duration t{0};
    auto res = call_with_stopwatch( t, [&]() {
      return engine( target, ~target.construct(), divisors.begin(), divisors.end(), divisor_functions, 20 );
    });
    if ( res )
    {
      exp( fmt::format( "{:#x}", classes[i] ), opt_sizes[i], res->num_gates(), to_seconds( t ) );
      num_success++;
      total_size += res->num_gates();
      total_overhead += res->num_gates() - opt_sizes[i];
    }
    else
    {
      exp( fmt::format( "{:#x}", classes[i] ), opt_sizes[i], 0, to_seconds( t ) );
    }
  }

  exp.save();
  exp.table();

  fmt::print( "success/total = {}/{}, avg. size = {:.2f}, avg. overhead = {:.2f}\n", num_success, classes.size(), float(total_size) / num_success, float(total_overhead) / num_success );

  return 0;
}